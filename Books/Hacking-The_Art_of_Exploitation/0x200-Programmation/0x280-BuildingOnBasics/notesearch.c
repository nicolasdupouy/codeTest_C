#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>	// "open" function
#include <unistd.h> // "write", "close" and "getuid" functions
#include <sys/stat.h>
#include "hacking.h"

#define FILENAME "/tmp/notes_with_userid"

int print_notes(int, int, char *);
int find_user_note(int, int);
int search_note(char *, char *);

int main(int argc, char *argv[])
{
	int userid, printing = 1, fd;
	char searchstring[100];

	if (argc > 1)
	{
		strcpy(searchstring, argv[1]);
	}
	else
	{
		searchstring[0] = 0;
	}

	userid = getuid();
	fd = open(FILENAME, O_RDONLY);
	if (fd == -1)
		fatal("in main() while opening file for reading");

	while (printing)
		printing = print_notes(fd, userid, searchstring);
	printf("-------------[ end of note data]-------------");
	close(fd);
}

// Fonction pour afficher les notes d'un utilisateur donné, qui correspondent à une chaîne de recherche facultative.
// Elle retourne 0 à la fin du fichier, 1 s'il reste d'autres notes.
int print_notes(int fd, int uid, char *searchstring)
{
	int note_length;
	char byte = 0, note_buffer[100];

	note_length = find_user_note(fd, uid);

	if (note_length == -1) // Si la fin du fichier a été atteinte,
		return 0;		   // retourner 0.

	read(fd, note_buffer, note_length); // Lire les données de la note.
	note_buffer[note_length] = 0;		// Terminer la chaîne.

	if (search_note(note_buffer, searchstring)) // Si searchstring est trouvée,
		printf(note_buffer);					// afficher la note.
	return 1;
}

// Fonction pour chercher la note suivante d'un utilisateur donné.
// Elle retourne -1 si la fin du fichier a été atteinte. Sinon elle retourne la longueur de la note trouvée.
int find_user_note(int fd, int user_uid)
{
	int note_uid = -1;
	unsigned char byte;
	int length;

	// Boucler jusqu'à ce qu'une note correspondant à user_uid soit trouvée.
	while (note_uid != user_uid)
	{
		if (read(fd, &note_uid, 4) != 4) // Lire l'identifiant utilisateur
			return -1;					 // Si 4 octets ne peuvent être lus, retourner le code de fin de fichier.

		if (read(fd, &byte, 1) != 1) // Lire le séparateur de ligne
			return -1;				 // Si 1 octet ne peut être lu, retourner le code de fin de fichier.

		byte = length = 0;

		while (byte != '\n') // Déterminer le nombre  d'octets jusqu'à la fin de la ligne
		{
			if (read(fd, &byte, 1) != 1) // Lire un seul octet
				return -1;				 // Si un octet ne peut pas être lu, retourner le code de fin de fichier.
			length++;
		}
	}

	// Reculer la lecture du fichier de length octets.
	lseek(fd, length * -1, SEEK_CUR);

	printf("[DEBUG] found a %d byte note for user id %d\n", length, note_uid);
}

// Fonction pour chercher une note qui correspond au mot clé indiqué.
// Elle retourne 1 si une correspondance est trouvée, 0 dans le cas contraire.
int search_note(char *note, char *keyword)
{
	int i, keyword_length, match = 0;

	keyword_length = strlen(keyword);
	if (keyword_length == 0) // Si la chaîne de recherche n'existe pas
		return 1;			 // toujours indiquer une correspondance

	for (i = 0; i < strlen(note); i++)
	{								   // Parcourir tous les octets de la note
		if (note[i] == keyword[match]) // Si l'octet correspond au mot clé
			match++;				   // se préparer à vérifier l'octet suivant
		else
		{
			if (note[i] == keyword[0]) // si l'octet correspond au premier octet du mot clé
				match = 1;
			else
				match = 0;
		}

		if (match = keyword_length)
			return 1;
	}

	return 0;
}